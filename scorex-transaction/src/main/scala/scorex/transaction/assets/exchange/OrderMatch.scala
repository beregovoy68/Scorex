package scorex.transaction.assets.exchange

import com.google.common.primitives.{Ints, Longs}
import play.api.libs.json.{JsObject, Json}
import scorex.crypto.EllipticCurveImpl
import scorex.crypto.encode.Base58
import scorex.crypto.hash.FastCryptographicHash
import scorex.serialization.{BytesSerializable, Deser}
import scorex.transaction._
import scala.util.Try

import scorex.transaction.assets.exchange

/**
  * Transaction with matched orders generated by Matcher service
  */
case class OrderMatch(buyOrder: Order, sellOrder: Order, price: Long, amount: Long, matcherFee: Long, fee: Long,
                      timestamp: Long, signature: Array[Byte]) extends Transaction with BytesSerializable {

  override val id: Array[Byte] = FastCryptographicHash(toSign)

  override val assetFee: (Option[AssetId], Long) = (None, fee)

  def isValid(previousMatches: Seq[OrderMatch]): Boolean = {
    lazy val buyTransactions = previousMatches.filter { om =>
      om.buyOrder.id sameElements buyOrder.id
    }
    lazy val sellTransactions = previousMatches.filter { om =>
      om.sellOrder.id sameElements sellOrder.id
    }

    lazy val prevBuyTotal = buyTransactions.map(_.amount).sum
    lazy val prevSellTotal = sellTransactions.map(_.amount).sum

    lazy val isSameAssets = {
      buyOrder.assetPair == sellOrder.assetPair
    }

    lazy val isSameMatchers = {
      buyOrder.matcher == sellOrder.matcher
    }

    lazy val priceIsValid: Boolean = price <= buyOrder.price && price >= sellOrder.price

    lazy val amountIsValid: Boolean = {
      val buyTotal = prevBuyTotal + amount
      val sellTotal = prevSellTotal + amount
      (buyTotal <= buyOrder.amount) && (sellTotal <= sellOrder.amount)
    }

    lazy val matcherFeeIsValid: Boolean = {

      matcherFee <= buyOrder.matcherFee * amount / buyOrder.amount +
        sellOrder.matcherFee * amount / sellOrder.amount

      //matcher takes part of fee = part of matched order
      //matcherFee == (buyOrder.matcherFee * amount / buyOrder.amount + sellOrder.matcherFee * amount / sellOrder
      // .amount)
    }

    lazy val matcherSignatureIsValid: Boolean =
      EllipticCurveImpl.verify(signature, toSign, buyOrder.matcher.publicKey)

    fee > 0 && amount > 0 && price > 0 &&
      buyOrder.orderType == OrderType.BUY &&
      sellOrder.orderType == OrderType.SELL &&
      isSameMatchers && isSameAssets &&
      buyOrder.isValid(timestamp) && sellOrder.isValid(timestamp) &&
      priceIsValid && amountIsValid && matcherFeeIsValid &&
      matcherSignatureIsValid
  }

  lazy val toSign: Array[Byte] = Ints.toByteArray(buyOrder.bytes.length) ++ Ints.toByteArray(sellOrder.bytes.length) ++
    buyOrder.bytes ++ sellOrder.bytes ++ Longs.toByteArray(price) ++ Longs.toByteArray(amount) ++
    Longs.toByteArray(matcherFee) ++ Longs.toByteArray(fee) ++ Longs.toByteArray(timestamp)

  override def bytes: Array[Byte] = toSign ++ signature

  override def json: JsObject = Json.obj(
    "order1" -> buyOrder.json,
    "order2" -> sellOrder.json,
    "price" -> price,
    "amount" -> amount,
    "matcherFee" -> matcherFee,
    "fee" -> fee,
    "timestamp" -> timestamp,
    "signature" -> Base58.encode(signature)
  )

  override def balanceChanges(): Seq[BalanceChange] = {

    val matcherChange = Seq(BalanceChange(AssetAcc(buyOrder.matcher, None), matcherFee - fee))
    val o1feeChange = Seq(BalanceChange(AssetAcc(buyOrder.sender, None), buyOrder.matcherFee * amount / buyOrder.amount))
    val o2feeChange = Seq(BalanceChange(AssetAcc(sellOrder.sender, None), sellOrder.matcherFee * amount / sellOrder.amount))

    val exchange = Seq(
      (buyOrder.sender, (buyOrder.spendAssetId, -amount * price / PriceConstant)),
      (buyOrder.sender, (buyOrder.receiveAssetId, amount)),
      (sellOrder.sender, (sellOrder.spendAssetId, -amount * price / PriceConstant)),
      (sellOrder.sender, (sellOrder.receiveAssetId, amount))
    )

    o1feeChange ++ o2feeChange ++ matcherChange ++
      exchange.map(c => BalanceChange(AssetAcc(c._1, Some(c._2._1)), c._2._2))
  }
}

object OrderMatch extends Deser[OrderMatch] {
  override def parseBytes(bytes: Array[Byte]): Try[OrderMatch] = Try {
    val o1Size = Ints.fromByteArray(bytes.slice(0, 4))
    val o2Size = Ints.fromByteArray(bytes.slice(4, 8))
    val o1 = Order.parseBytes(bytes.slice(8, 8 + o1Size)).get
    val o2 = Order.parseBytes(bytes.slice(8 + o1Size, 8 + o1Size + o2Size)).get
    val s = 8 + o1Size + o2Size
    val price = Longs.fromByteArray(bytes.slice(s, s + 8))
    val amount = Longs.fromByteArray(bytes.slice(s + 8, s + 16))
    val matcherFee = Longs.fromByteArray(bytes.slice(s + 16, s + 24))
    val fee = Longs.fromByteArray(bytes.slice(s + 24, s + 32))
    val timestamp = Longs.fromByteArray(bytes.slice(s + 32, s + 40))
    val signature = bytes.slice(s + 40, bytes.length)
    OrderMatch(o1, o2, price, amount, matcherFee, fee, timestamp, signature)
  }
}
